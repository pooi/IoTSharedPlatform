extends layout

block content

    link(href='/styles/quill.core.css', rel='stylesheet')
    link(href='/styles/quill.snow.css', rel='stylesheet')
    link(href='/styles/quill.bubble.css', rel='stylesheet')
    script(src='/scripts/quill.min.js')
    script(src='/scripts/vue-quill-editor.js')
    script.
        mxBasePath = '/scripts/src';
    script(src='/scripts/mxClient.js')

    script(src='/scripts/go.js')


    include toolbar


    v-content.brown.lighten-5.animation-fade-in(style="padding-top: 50px")
        //v-container.pa-0(:fluid="$vuetify.breakpoint.xsOnly || $vuetify.breakpoint.smOnly")
        v-container.pa-0()

            v-flex(md12='')
                //v-card.pa-3.safe-area-inset(:class="$vuetify.breakpoint.xsOnly || $vuetify.breakpoint.smOnly  ? 'elevation-0 mb-4 pt-4' : 'elevation-10 my-4'")
                v-card.safe-area-inset.elevation-0.mb-4(:class="$vuetify.breakpoint.xsOnly || $vuetify.breakpoint.smOnly  ? 'pt-3 pb-0 px-0' : 'pa-3'")

                    v-card-title.pb-0(style="margin-top: 20px;")
                        span.display-2(style="font-weight: 800;") 글 작성

                    v-card-text.py-0
                        v-divider.my-3

                    v-card-text
                        v-layout
                            v-flex(xs12)
                                v-card.pa-0.elevation-4
                                    v-card-text.py-2.mt-4
                                        span.headline.red--text.text--darken-1(style="font-weight: 700;") 설계도
                                        v-card.my-3.elevation-6(height="250px")
                                            v-layout(row, wrap, justify-center, align-center, style="width: 100%; height: 100%;")
                                                div#graph(style="width: 100%; height: 100%; overflow:auto; ")


                                    v-card-text.py-2.mt-4
                                        span.headline.red--text.text--darken-1(style="font-weight: 700;") 설계도
                                        v-card.my-3.elevation-6(height="250px")
                                            v-layout(row, wrap, justify-center, align-center, style="width: 100%; height: 100%;")
                                                div#myDiagramDiv(style="width: 100%; height: 100%;")
                                    v-card-actions
                                        v-btn(flat, @click="graphManager.save()") Save
                                        v-btn(flat, @click="graphManager.load()") Load




    include footer
    include bottom_tab

    script.
        $(document).ready(function () {
            main(document.getElementById("graph"));
        });

        // Overridden to define per-shape connection points
        mxGraph.prototype.getAllConnectionConstraints = function (terminal, source) {
            if (terminal != null && terminal.shape != null) {
                if (terminal.shape.stencil != null) {
                    if (terminal.shape.stencil != null) {
                        return terminal.shape.stencil.constraints;
                    }
                }
                else if (terminal.shape.constraints != null) {
                    return terminal.shape.constraints;
                }
            }

            return null;
        };

        // Defines the default constraints for all shapes
        mxShape.prototype.constraints = [new mxConnectionConstraint(new mxPoint(0.25, 0), true),
            new mxConnectionConstraint(new mxPoint(0.5, 0), true),
            new mxConnectionConstraint(new mxPoint(0.75, 0), true),
            new mxConnectionConstraint(new mxPoint(0, 0.25), true),
            new mxConnectionConstraint(new mxPoint(0, 0.5), true),
            new mxConnectionConstraint(new mxPoint(0, 0.75), true),
            new mxConnectionConstraint(new mxPoint(1, 0.25), true),
            new mxConnectionConstraint(new mxPoint(1, 0.5), true),
            new mxConnectionConstraint(new mxPoint(1, 0.75), true),
            new mxConnectionConstraint(new mxPoint(0.25, 1), true),
            new mxConnectionConstraint(new mxPoint(0.5, 1), true),
            new mxConnectionConstraint(new mxPoint(0.75, 1), true)];

        // Edges have no connection points
        mxPolyline.prototype.constraints = null;

        function main(container) {
            // Checks if the browser is supported
            if (!mxClient.isBrowserSupported()) {
                // Displays an error message if the browser is not supported.
                mxUtils.error('Browser is not supported!', 200, false);
            }
            else {
                // To detect if touch events are actually supported, the following condition is recommended:
                // mxClient.IS_TOUCH || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0

                // Disables built-in text selection and context menu while not editing text
                var textEditing = mxUtils.bind(this, function (evt) {
                    return graph.isEditing();
                });

                container.onselectstart = textEditing;
                container.onmousedown = textEditing;

                if (mxClient.IS_IE && (typeof(document.documentMode) === 'undefined' || document.documentMode < 9)) {
                    mxEvent.addListener(container, 'contextmenu', textEditing);
                }
                else {
                    container.oncontextmenu = textEditing;
                }

                // Creates the graph inside the given container
                var graph = new mxGraph(container);
                graph.centerZoom = false;
                graph.setConnectable(true);
                graph.setPanning(true);

                // Changes the default style for edges "in-place"
                var style = graph.getStylesheet().getDefaultEdgeStyle();
                style[mxConstants.STYLE_ROUNDED] = true;
                style[mxConstants.STYLE_EDGE] = mxEdgeStyle.OrthConnector;

                // Creates rubberband selection
                var rubberband = new mxRubberband(graph);

                graph.popupMenuHandler.autoExpand = true;

                graph.popupMenuHandler.isSelectOnPopup = function (me) {
                    return mxEvent.isMouseEvent(me.getEvent());
                };

                // Installs context menu
                graph.popupMenuHandler.factoryMethod = function (menu, cell, evt) {
                    menu.addItem('Add node', null, function () {
                        console.log(menu, cell, evt);
                        var parent = graph.getDefaultParent();
                        graph.getModel().beginUpdate();
                        try {
                            var v1 = graph.insertVertex(parent, null, 'New node', evt.layerX, evt.layerY, 80, 30);
                        }
                        finally {
                            // Updates the display
                            graph.getModel().endUpdate();
                        }
                    });

                    if(cell !== null){
                        menu.addSeparator();

                        menu.addItem("Delete", null, function () {
                            // cell.removeFromParent();
                            console.log("Delete", cell);
                        });

                        // var submenu1 = menu.addItem('Submenu 1', null, null);
                        //
                        // menu.addItem('Subitem 1', null, function () {
                        //     alert('Subitem 1');
                        // }, submenu1);
                        // menu.addItem('Subitem 1', null, function () {
                        //     alert('Subitem 2');
                        // }, submenu1);
                    }
                };

                // Context menu trigger implementation depending on current selection state
                // combined with support for normal popup trigger.
                var cellSelected = false;
                var selectionEmpty = false;
                var menuShowing = false;

                graph.fireMouseEvent = function (evtName, me, sender) {
                    if (evtName == mxEvent.MOUSE_DOWN) {
                        // For hit detection on edges
                        me = this.updateMouseEvent(me);

                        cellSelected = this.isCellSelected(me.getCell());
                        selectionEmpty = this.isSelectionEmpty();
                        menuShowing = graph.popupMenuHandler.isMenuShowing();
                    }

                    mxGraph.prototype.fireMouseEvent.apply(this, arguments);
                };

                // Shows popup menu if cell was selected or selection was empty and background was clicked
                graph.popupMenuHandler.mouseUp = function (sender, me) {
                    this.popupTrigger = !graph.isEditing() && (this.popupTrigger || (!menuShowing &&
                        !graph.isEditing() && !mxEvent.isMouseEvent(me.getEvent()) &&
                        ((selectionEmpty && me.getCell() == null && graph.isSelectionEmpty()) ||
                            (cellSelected && graph.isCellSelected(me.getCell())))));
                    mxPopupMenuHandler.prototype.mouseUp.apply(this, arguments);
                };

                // Tap and hold on background starts rubberband for multiple selected
                // cells the cell associated with the event is deselected
                graph.addListener(mxEvent.TAP_AND_HOLD, function (sender, evt) {
                    if (!mxEvent.isMultiTouchEvent(evt)) {
                        var me = evt.getProperty('event');
                        var cell = evt.getProperty('cell');

                        if (cell == null) {
                            var pt = mxUtils.convertPoint(this.container,
                                mxEvent.getClientX(me), mxEvent.getClientY(me));
                            rubberband.start(pt.x, pt.y);
                        }
                        else if (graph.getSelectionCount() > 1 && graph.isCellSelected(cell)) {
                            graph.removeSelectionCell(cell);
                        }

                        // Blocks further processing of the event
                        evt.consume();
                    }
                });

                // Adds mouse wheel handling for zoom
                // mxEvent.addMouseWheelListener(function (evt, up) {
                //     if (up) {
                //         graph.zoomIn();
                //     }
                //     else {
                //         graph.zoomOut();
                //     }
                //
                //     mxEvent.consume(evt);
                // });

                // Gets the default parent for inserting new cells. This
                // is normally the first child of the root (ie. layer 0).
                var parent = graph.getDefaultParent();

                // Adds cells to the model in a single step
                graph.getModel().beginUpdate();
                try {
                    var v1 = graph.insertVertex(parent, null, 'Hello,', 20, 20, 80, 30);
                    var v2 = graph.insertVertex(parent, null, 'World!', 200, 150, 80, 30);
                    var e1 = graph.insertEdge(parent, null, '', v1, v2);
                }
                finally {
                    // Updates the display
                    graph.getModel().endUpdate();
                }

                // Disables new connections via "hotspot"
                graph.connectionHandler.marker.isEnabled = function () {
                    return this.graph.connectionHandler.first != null;
                };

                // Adds custom hit detection if native hit detection found no cell
                graph.updateMouseEvent = function (me) {
                    var me = mxGraph.prototype.updateMouseEvent.apply(this, arguments);

                    if (me.getState() == null) {
                        var cell = this.getCellAt(me.graphX, me.graphY);

                        if (cell != null && this.isSwimlane(cell) && this.hitsSwimlaneContent(cell, me.graphX, me.graphY)) {
                            cell = null;
                        }
                        else {
                            me.state = this.view.getState(cell);

                            if (me.state != null && me.state.shape != null) {
                                this.container.style.cursor = me.state.shape.node.style.cursor;
                            }
                        }
                    }

                    if (me.getState() == null) {
                        this.container.style.cursor = 'default';
                    }

                    return me;
                };

                var buttons = document.createElement('div');
                buttons.style.position = 'absolute';
                buttons.style.overflow = 'visible';

                var bs = graph.getBorderSizes();
                buttons.style.top = (container.offsetTop + bs.y) + 'px';
                buttons.style.left = (container.offsetLeft + bs.x) + 'px';

                var left = 0;
                var bw = 16;
                var bh = 16;

                if (mxClient.IS_QUIRKS) {
                    bw -= 1;
                    bh -= 1;
                }

                function addButton(label, funct) {
                    var btn = document.createElement('div');
                    mxUtils.write(btn, label);
                    btn.style.position = 'absolute';
                    btn.style.backgroundColor = 'transparent';
                    btn.style.border = '1px solid gray';
                    btn.style.textAlign = 'center';
                    btn.style.fontSize = '10px';
                    btn.style.cursor = 'hand';
                    btn.style.width = bw + 'px';
                    btn.style.height = bh + 'px';
                    btn.style.left = left + 'px';
                    btn.style.top = '0px';

                    mxEvent.addListener(btn, 'click', function (evt) {
                        funct();
                        mxEvent.consume(evt);
                    });

                    left += bw;

                    buttons.appendChild(btn);
                };

                addButton('+', function () {
                    graph.zoomIn();
                });

                addButton('-', function () {
                    graph.zoomOut();
                });
            }
        };

        (function () {
            // Enables rotation handle
            mxVertexHandler.prototype.rotationEnabled = true;

            // Enables managing of sizers
            mxVertexHandler.prototype.manageSizers = true;

            // Enables live preview
            mxVertexHandler.prototype.livePreview = true;

            // Sets constants for touch style
            mxConstants.HANDLE_SIZE = 16;
            mxConstants.LABEL_HANDLE_SIZE = 7;

            // Larger tolerance and grid for real touch devices
            if (mxClient.IS_TOUCH || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0) {
                mxShape.prototype.svgStrokeTolerance = 18;
                mxVertexHandler.prototype.tolerance = 12;
                mxEdgeHandler.prototype.tolerance = 12;
                mxGraph.prototype.tolerance = 12;
            }

            // One finger pans (no rubberband selection) must start regardless of mouse button
            mxPanningHandler.prototype.isPanningTrigger = function (me) {
                var evt = me.getEvent();

                return (me.getState() == null && !mxEvent.isMouseEvent(evt)) ||
                    (mxEvent.isPopupTrigger(evt) && (me.getState() == null ||
                        mxEvent.isControlDown(evt) || mxEvent.isShiftDown(evt)));
            };

            // Don't clear selection if multiple cells selected
            var graphHandlerMouseDown = mxGraphHandler.prototype.mouseDown;
            mxGraphHandler.prototype.mouseDown = function (sender, me) {
                graphHandlerMouseDown.apply(this, arguments);

                if (this.graph.isCellSelected(me.getCell()) && this.graph.getSelectionCount() > 1) {
                    this.delayedSelection = false;
                }
            };

            // On connect the target is selected and we clone the cell of the preview edge for insert
            mxConnectionHandler.prototype.selectCells = function (edge, target) {
                if (target != null) {
                    this.graph.setSelectionCell(target);
                }
                else {
                    this.graph.setSelectionCell(edge);
                }
            };

            // Overrides double click handling to use the tolerance
            var graphDblClick = mxGraph.prototype.dblClick;
            mxGraph.prototype.dblClick = function (evt, cell) {
                if (cell == null) {
                    var pt = mxUtils.convertPoint(this.container,
                        mxEvent.getClientX(evt), mxEvent.getClientY(evt));
                    cell = this.getCellAt(pt.x, pt.y);
                }

                graphDblClick.call(this, evt, cell);
            };

            // Rounded edge and vertex handles
            var touchHandle = new mxImage('/resources/handle-main.png', 17, 17);
            mxVertexHandler.prototype.handleImage = touchHandle;
            mxEdgeHandler.prototype.handleImage = touchHandle;
            mxOutline.prototype.sizerImage = touchHandle;

            // Pre-fetches touch handle
            new Image().src = touchHandle.src;

            // Adds connect icon to selected vertex
            var connectorSrc = '/resources/handle-connect.png';

            var vertexHandlerInit = mxVertexHandler.prototype.init;
            mxVertexHandler.prototype.init = function () {
                // TODO: Use 4 sizers, move outside of shape
                //this.singleSizer = this.state.width < 30 && this.state.height < 30;
                vertexHandlerInit.apply(this, arguments);

                // Only show connector image on one cell and do not show on containers
                if (this.graph.connectionHandler.isEnabled() &&
                    this.graph.isCellConnectable(this.state.cell) &&
                    this.graph.getSelectionCount() == 1) {
                    this.connectorImg = mxUtils.createImage(connectorSrc);
                    this.connectorImg.style.cursor = 'pointer';
                    this.connectorImg.style.width = '29px';
                    this.connectorImg.style.height = '29px';
                    this.connectorImg.style.position = 'absolute';

                    if (!mxClient.IS_TOUCH) {
                        this.connectorImg.setAttribute('title', mxResources.get('connect'));
                        mxEvent.redirectMouseEvents(this.connectorImg, this.graph, this.state);
                    }

                    // Starts connecting on touch/mouse down
                    mxEvent.addGestureListeners(this.connectorImg,
                        mxUtils.bind(this, function (evt) {
                            this.graph.popupMenuHandler.hideMenu();
                            this.graph.stopEditing(false);

                            var pt = mxUtils.convertPoint(this.graph.container,
                                mxEvent.getClientX(evt), mxEvent.getClientY(evt));
                            this.graph.connectionHandler.start(this.state, pt.x, pt.y);
                            this.graph.isMouseDown = true;
                            this.graph.isMouseTrigger = mxEvent.isMouseEvent(evt);
                            mxEvent.consume(evt);
                        })
                    );

                    this.graph.container.appendChild(this.connectorImg);
                }

                this.redrawHandles();
            };

            var vertexHandlerHideSizers = mxVertexHandler.prototype.hideSizers;
            mxVertexHandler.prototype.hideSizers = function () {
                vertexHandlerHideSizers.apply(this, arguments);

                if (this.connectorImg != null) {
                    this.connectorImg.style.visibility = 'hidden';
                }
            };

            var vertexHandlerReset = mxVertexHandler.prototype.reset;
            mxVertexHandler.prototype.reset = function () {
                vertexHandlerReset.apply(this, arguments);

                if (this.connectorImg != null) {
                    this.connectorImg.style.visibility = '';
                }
            };

            var vertexHandlerRedrawHandles = mxVertexHandler.prototype.redrawHandles;
            mxVertexHandler.prototype.redrawHandles = function () {
                vertexHandlerRedrawHandles.apply(this);

                if (this.state != null && this.connectorImg != null) {
                    var pt = new mxPoint();
                    var s = this.state;

                    // Top right for single-sizer
                    if (mxVertexHandler.prototype.singleSizer) {
                        pt.x = s.x + s.width - this.connectorImg.offsetWidth / 2;
                        pt.y = s.y - this.connectorImg.offsetHeight / 2;
                    }
                    else {
                        pt.x = s.x + s.width + mxConstants.HANDLE_SIZE / 2 + 4 + this.connectorImg.offsetWidth / 2;
                        pt.y = s.y + s.height / 2;
                    }

                    var alpha = mxUtils.toRadians(mxUtils.getValue(s.style, mxConstants.STYLE_ROTATION, 0));

                    if (alpha != 0) {
                        var cos = Math.cos(alpha);
                        var sin = Math.sin(alpha);

                        var ct = new mxPoint(s.getCenterX(), s.getCenterY());
                        pt = mxUtils.getRotatedPoint(pt, cos, sin, ct);
                    }

                    this.connectorImg.style.left = (pt.x - this.connectorImg.offsetWidth / 2) + 'px';
                    this.connectorImg.style.top = (pt.y - this.connectorImg.offsetHeight / 2) + 'px';
                }
            };

            var vertexHandlerDestroy = mxVertexHandler.prototype.destroy;
            mxVertexHandler.prototype.destroy = function (sender, me) {
                vertexHandlerDestroy.apply(this, arguments);

                if (this.connectorImg != null) {
                    this.connectorImg.parentNode.removeChild(this.connectorImg);
                    this.connectorImg = null;
                }
            };

            // Pre-fetches touch connector
            new Image().src = connectorSrc;
        })();

    script(type="text/javascript" src='/javascripts/graph-test-config.js')
    script.
        const vue = init('!{user}');